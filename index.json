[{"authors":["admin"],"categories":null,"content":"I am currently a Research Associate in the Software Reliability Group at Imperial College London, under the direction of Pr Cristian Cadar. For now, I am experimenting with the Chopper tool in order to automatize the selection of skipped code regions.\nLast year, I was a postdoctoral researcher at University of Lille, in the CRIStAL labs. My research work revolved around techniques, algorithms and abstractions for the static analysis of binary code, and a better understanding of its underlying structures. When not on a whiteboard, I would develop prototypes for the OTAWA WCET tool, or teach at the Polytech engineering school.\nI received my PhD in static program analysis at age 24 from the University of Toulouse III where I was delighted to work closely with Hugues Cassé on OTAWA. I engineered PathFinder, a tool for infeasible path detection on binary code, which parses the graph representation of a program and looks for impossible execution paths. It outputs data flow properties that provably tighten WCET estimations, necessary to safely develop critical systems, namely in aeronautics and space.\n","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"598b63dd58b43bce02403646f240cd3c","permalink":"https://dune-jr.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"author","summary":"I am currently a Research Associate in the Software Reliability Group at Imperial College London, under the direction of Pr Cristian Cadar. For now, I am experimenting with the Chopper tool in order to automatize the selection of skipped code regions.\nLast year, I was a postdoctoral researcher at University of Lille, in the CRIStAL labs. My research work revolved around techniques, algorithms and abstractions for the static analysis of binary code, and a better understanding of its underlying structures.","tags":null,"title":"Jordy Ruiz","type":"author"},{"authors":null,"categories":null,"content":" PathFinder  Building Running Documentation  ","date":1536447600,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1536447600,"objectID":"4cdd37113783e47641dd300543c94e1b","permalink":"https://dune-jr.github.io/docs/","publishdate":"2018-09-09T00:00:00+01:00","relpermalink":"/docs/","section":"docs","summary":" PathFinder  Building Running Documentation  ","tags":null,"title":"Documentation","type":"docs"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"5562f48ca221af119550a5b86c623090","permalink":"https://dune-jr.github.io/teaching/experience/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/teaching/experience/","section":"teaching","summary":"","tags":null,"title":"Experience","type":"teaching"},{"authors":["Clément Ballabriga","Julien Forget","Laure Gonnord","Giuseppe Lipari","Jordy Ruiz"],"categories":null,"content":"","date":1547337600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1547337600,"objectID":"1130ff89ee77234348b7741f580196df","permalink":"https://dune-jr.github.io/publication/vmcai19/","publishdate":"2019-01-13T00:00:00Z","relpermalink":"/publication/vmcai19/","section":"publication","summary":"In this paper we propose a new abstract domain for static analysis of binary code. Our motivation stems from the need to improve the precision of the estimation of the Worst-Case Execution Time (WCET) of safety-critical real-time code. WCET estimation requires computing information such as upper bounds on the number of loop iterations, unfeasible execution paths, etc. These estimations are usually performed on binary code, mainly to avoid making assumptions on how the compiler works. Our abstract domain, based to polyhedra and on two mapping functions that associate polyhedra variables with registers and memory, targets the precise computation of such information. We prove the correctness of the method, and demonstrate its effectiveness on benchmarks and examples from typical embedded code.","tags":[],"title":"Static Analysis Of Binary Code With Memory Indirections Using Polyhedra","type":"publication"},{"authors":null,"categories":null,"content":" The following contains instructions to get a working PathFinder build. PathFinder only runs on Linux.\nDownloading PathFinder You can get the sources over at Github, or use this direct link to the ZIP archive.\nRequirements bam PathFinder uses the bam build system. Get it from Github or install the Debian package:\n apt-get install bam  OTAWA Get it at http://otawa.fr/. You will need OTAWA v2. If you run into trouble with dependencies on Debian, I suggest using\n apt-get install flex bison bzr g++ ocaml libxml2-dev libxslt-dev mercurial  An SMT solver PathFinder supports two SMT solvers, CVC4 and z3. You can use either with very comparable performances and almost identical outputs.\nCVC4 If you have admin rights on your machine, you can get CVC4 with an automated script:\n ./get_cvc4.sh  You may also want to try a local install (which can be trickier) with\n ./get_cvc4_local/all.sh  Z3 Z3 tends to be significantly less tricky to install. You can follow the instructions at https://github.com/Z3Prover/z3.\nInstalling PathFinder To install, type bam and follow the instructions. bam config will run a default config, which you can reset by removing the config.lua file. In order to select either solver, use bam config solver=cvc4 or bam config solver=z3.\nAlternatively, you can use ./make_cvc4 or ./make_z3.\nNote: In order to run PathFinder with maximum performance (for benchmarking), you must run bam config O=3 debug=false warnings=false v1=false.\nNote: If your terminal does not support UTF-8, use bam config utf8=false\n","date":1536447600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1536447600,"objectID":"e6b124fa6f35eda2eca36e3c8eda29cb","permalink":"https://dune-jr.github.io/docs/building_pathfinder/","publishdate":"2018-09-09T00:00:00+01:00","relpermalink":"/docs/building_pathfinder/","section":"docs","summary":"The following contains instructions to get a working PathFinder build. PathFinder only runs on Linux.\nDownloading PathFinder You can get the sources over at Github, or use this direct link to the ZIP archive.\nRequirements bam PathFinder uses the bam build system. Get it from Github or install the Debian package:\n apt-get install bam  OTAWA Get it at http://otawa.fr/. You will need OTAWA v2. If you run into trouble with dependencies on Debian, I suggest using","tags":null,"title":"Building PathFinder","type":"docs"},{"authors":null,"categories":null,"content":"Documentation for PathFinder\u0026rsquo;s public classes can be generated by running doxygen at the root of the installation directory.\nThe Classes Index document is located at autodoc/classes.html.\n","date":1536447600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1536447600,"objectID":"3d1b2797a4687f2871f6c5fd307dc9fa","permalink":"https://dune-jr.github.io/docs/docs_pathfinder/","publishdate":"2018-09-09T00:00:00+01:00","relpermalink":"/docs/docs_pathfinder/","section":"docs","summary":"Documentation for PathFinder\u0026rsquo;s public classes can be generated by running doxygen at the root of the installation directory.\nThe Classes Index document is located at autodoc/classes.html.","tags":null,"title":"Documentation","type":"docs"},{"authors":null,"categories":null,"content":" The following contains instructions for the usage of PathFinder. You will find the pathfinder binaries at the root of the install folder.\nBasic use Calls to PathFinder must follow the pathfinder [OPTIONS] PROGRAM [FUNCTION] pattern. Options can be nested as long as they are one letter. Example:\npathfinder -3pa benchmarks/if_then_else_2seq.elf  Abstract interpretation modules PathFinder comes with three abstract interpretation modules, named by their chronological order of development. Older versions are kept for academic interest.\n -3 is the most recent, best module. It uses modular analysis with composable states and has all the latest developments.\n -2 does not make use of contextual analysis, but uses a similar abstract interpretation domain as -3.\n -1 purely uses symbolic predicates to represent program states. Warning: in order to run with -1, you must configure the pathfinder build with bam config v1=true.\n  You can run pathfinder with no other options on binary files supported by OTAWA.\nOptions Options are documented if you run pathfinder -h. You are most likely only interested in the following:\nComplexity control You will quickly find that PathFinder runs too slow (or runs out of memory) on even most basic programs. This is normal, because it does not by default use any merge algorithm to cope with the exponential complexity of the representation of the program it uses. Thankfully, there are options that allows PathFinder to make a tradeoff between precision and complexity and run on reasonably-sized programs.\nYou can set merge points using\n --automerge, -a let the algorithm decide when to merge  --automerge applies a merge when it runs into 250 or more states. You can adjust this number with the following option:\n --merge, -m merge when exceeding X states at a control point  On some of the largest benchmarks, another factor of complexity explosion is the size of predicates. If --automerge does not suffice, add this option:\n --clamp_predicates, --cp (optimization) clamp predicates size (12 operands max)  If the analysis still takes too long, or too much memory, when using -3, add this option (I think I did not have to use this on any of the Mälardalens):\n --maf, --merge-after-apply (optimization) allow the algorithm to merge immediately after applying  If you are not interested in the infeasible paths output:\n --slice slice away instructions that do not impact the control flow (warning: removes infeasible paths!). This requires PathFinder to be configured with bam config slice=true  Console output control PathFinder comes with many options to control the console output, which is quite verbose and colorful by default. On larger benchmarks, I like using -p.\nVerbose  --s0, --vv, -V: high verbose, run with maximal output\n --s1, -s low verbose, only display results\n --s2, -S zero verbose, run with no output\n --progress, -p display analysis progress (forces --s1 or higher)\n  Other  --nc, --no-color, --no-colors do not use colors. PathFinder is very colorful by default\n --src-info, -i print file/line number info\n --nir, --no-ip-results do not print the list of IPs found\n --nl, --no-line-nb do not number lines of the output\n --detailed-stats, --ds display detailed stats, including average length of infeasible_paths found etc.\n --loop-bounds, -l ONLY print loop bounds (no infeasible paths)\n  Outputting FFX results PathFinder can output its results in a ***_ips.ffx file. You must set this flag for this:\n --output, -o output the result of the analysis to a FFX file  You may also want to get some stats in a .tsv file:\n --graph-output, -g also output as a gnuplot .tsv graph file (requires -o)  Other If you are running into crashes due to irregular loops:\n --reduce reduce irregular loops  If you want to run quickly through the program without the infeasible path detection bit:\n --dry, -d dry run (no solver calls)  If you need to provide additional flow facts to PathFinder, use this OTAWA-inherited option:\n --flowfacts, -f PATH select the flowfacts to load  If you run into assert failures:\n --dasp, --dont-assume-id-sp do not assume sp = SP0 at the end of a function\n --deterministic, -D Ensure deterministic output (two executions give the same output).\n  For debugging, as it is interesting to know when you lose the stack pointer (you probably won\u0026rsquo;t get any result afterwards):\n --sp-critical Abort analysis on loss of SP info  ","date":1536447600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1536447600,"objectID":"b7713d102e38bd65f50903e96c79a8a7","permalink":"https://dune-jr.github.io/docs/running_pathfinder/","publishdate":"2018-09-09T00:00:00+01:00","relpermalink":"/docs/running_pathfinder/","section":"docs","summary":"The following contains instructions for the usage of PathFinder. You will find the pathfinder binaries at the root of the install folder.\nBasic use Calls to PathFinder must follow the pathfinder [OPTIONS] PROGRAM [FUNCTION] pattern. Options can be nested as long as they are one letter. Example:\npathfinder -3pa benchmarks/if_then_else_2seq.elf  Abstract interpretation modules PathFinder comes with three abstract interpretation modules, named by their chronological order of development. Older versions are kept for academic interest.","tags":null,"title":"Running PathFinder","type":"docs"},{"authors":["Jordy Ruiz","Hugues Cassé","Marianne De Michiel"],"categories":null,"content":"","date":1505689200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1505689200,"objectID":"4ce158367b64db42b92d5c592e472069","permalink":"https://dune-jr.github.io/publication/scam17/","publishdate":"2017-09-18T00:00:00+01:00","relpermalink":"/publication/scam17/","section":"publication","summary":"Infeasible paths are a major cause of overestimation of the Worst-Case Execution Time (WCET): without data flow constraints, static analysis by implicit path enumeration will take into account semantically impossible, potentially expensive execution paths, making the Worst-Case Execution Path unreachable in practice. We present in this paper an approach that allows to significantly tighten the WCET by identifying infeasible paths, namely in loops, and injecting them as additional Integer Linear Programming (ILP) constraints during the WCET computation.","tags":[],"title":"Working Around Loops for Infeasible Path Detection in Binary Programs","type":"publication"}]